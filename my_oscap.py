import argparse
import os
from subprocess import CalledProcessError
import sys
import subprocess
import json
import socket

from time import gmtime, strftime
from bs4 import BeautifulSoup

class XMLError(Exception):
    def __init__(self, msg = ""):
        self.message = '[XML ERROR]: XML operation failed with error message: {}'.format(msg)

    def __str__(self):
        return self.message

class JSONError(Exception):
    def __init__(self, msg = ""):
        self.message = '[JSON ERROR]: JSON operation failed with error message: {}'.format(msg)

    def __str__(self):
        return self.message

class Report():

    result_folder = None
    scan_id_1 = None
    scan_id_2 = None
    xml_to_parse = None

    def __init__(self, scan_id_1 = None, scan_id_2 = None, xml_to_parse = None, output_folder = '/root/scans/'):
        self.scan_id_1 = scan_id_1
        self.scan_id_2 = scan_id_2
        self.xml_to_parse = xml_to_parse
        self.result_folder = output_folder

    @staticmethod
    def parseResult(rule_result_tag):
        '''
        Returns a dict from the XML tags. Tags saved are severity and result text.

            Parameters: 
                rule_result_tag: Rule Result Tag obtained from result XML
        '''
        result = {}
        result['severity'] = rule_result_tag.get('severity')
        result['result'] = rule_result_tag.result.text
        return result

    @staticmethod
    def loadXML(xml_to_load_path):
        '''
        Returns a BeautifulSoup object created from the file located at xml_to_load_path

            Parameters:
                xml_to_load_path: Path of the file to read
        '''
        try:
            with open(xml_to_load_path, 'r') as file:
                return BeautifulSoup(file, 'xml')
        except:
            raise XMLError('Error parsing file: {}'.format(xml_to_load_path))

    @staticmethod
    def loadJSON(json_to_load_path):
        '''
        Returns a python object created from the file located at json_to_load_path

            Parameters:
                json_to_load_path: Path of the file to read
        '''
        try:
            with open(json_to_load_path, 'r') as file:
                return json.load(file)
        except:
            raise JSONError('Error reading JSON file: {}'.format(json_to_load_path))

    @staticmethod
    def writeJSON(filepath, data_to_write):
        '''
        Creates a new JSON file at filepath containing data_to_write

            Parameters:
                filepath: Path of the file to write
                data_to_write: Data that will be written to file
        '''
        try:
            with open(filepath, 'w') as file:
                json.dump(data_to_write, file)
        except:
            raise JSONError('Error writing to JSON file: {}'.format(filepath))

    @staticmethod
    def enumerateFilesInDir(dirpath):
        '''
        Returns a list of files in the given directory

            Parameters:
                dirpath: Path of the dictionary to enumerate
        '''
        try:
            return os.listdir(dirpath)
        except:
            raise FileNotFoundError('[FileNotFoundError]: Error walking dir with path: {}'.format(dirpath))

    def parseReport(self):
        '''
        Scans the report generated by oscap, focusing on the TestResult tag to obtain the results of the scan.
        Generates a JSON file located at result_folder containing the executed rules, text description and pass or fail status.
        Prints a summary of the results to stdout.

            Parameters: 
                xmlFile: String containing the path to the result XML file generated by oscap.
        '''
        rule_result = [{'stats':{'total':0, 'pass':0, 'fail':0}}, {}]


        try:
            soup = Report.loadXML(self.xml_to_parse)
        except XMLError as err:
            raise err

        test_target = soup.find('TestResult').target.text
        test_time = soup.find('TestResult').get('end-time')

        for rule_result_tag in soup.find_all('rule-result'):
            result = rule_result_tag.result.text
            if(result == 'notselected' or result == 'notapplicable'):
                continue
            rule_result[-1][rule_result_tag.get('idref')] = Report.parseResult(rule_result_tag)
            if result == 'pass':
                rule_result[0]['stats']['pass']+=1
            elif result == 'fail':
                rule_result[0]['stats']['fail']+=1

        rule_result[0]['stats']['total'] = len(rule_result[-1])

        try:
            Report.writeJSON(self.result_folder+test_target+'_'+test_time+'.json', rule_result)
        except JSONError as err:
            raise err
        
        for key in rule_result[-1]:
            print('ID: {}\nSeverity: {}\nResult: {}\n'.format(key, rule_result[-1][key]['severity'], rule_result[-1][key]['result']))
        
        print('[INFO]\nTest Target: {}\nUTC Time: {}\nTotal tests: {}\nPassed: {}\nFailed: {}\nNot Executed: {}'.format(test_target, test_time, rule_result[0]['stats']['total'], rule_result[0]['stats']['pass'], rule_result[0]['stats']['fail'], rule_result[0]['stats']['total'] - rule_result[0]['stats']['pass'] - rule_result[0]['stats']['fail']))

    def getFilenameById(self, scan_id):
        '''
        Returns a file that matches with the ID provided as parameter. 

            Parameters: 
                fileID: ID of the file to return
        '''
        
        files = Report.enumerateFilesInDir(self.result_folder)
            
        id = 1

        sortedFiles = sorted(files, key=lambda x: os.path.splitext(x.split('_')[-1])[0])

        for file in sortedFiles:
            if(int(scan_id) == id):
                return self.result_folder + file
            id+=1
        
        raise FileNotFoundError('[FileNotFoundError]: File with ID {} was not found'.format(scan_id))

    def compareReports(self):
        '''
        Compares two reports generated by this tool. Returns the summary statistics of each report, along with 4 lists:
            Issues resolved in the second report.
            New issues found in the second report.
            Executed rules from the first report missing in the second report.
            Executed rules from the second report missing in the first report.

            Parameters: 
                id_1: ID of the file to compare
                id_2: ID of the file to compare against
        '''
        fixed_issues = []
        new_issues = []
        unmatched_issues_1 = []
        unmatched_issues_2 = []

        try:
            file_1 = self.getFilenameById(self.scan_id_1)
            file_2 = self.getFilenameById(self.scan_id_2)
        except FileNotFoundError as err:
            raise err

        try:
            rule_result_1 = Report.loadJSON(file_1)
            rule_result_2 = Report.loadJSON(file_2)
        except JSONError as err:
            raise err

        for key in rule_result_1[-1]:
            key_2 = rule_result_2[-1].get(key, None)
            if key_2 is None:
                unmatched_issues_1.append(key)

        for key in rule_result_2[-1]:
            key_1 = rule_result_1[-1].get(key, None)
            if key_1 is not None:
                if rule_result_1[-1][key]['result'] == 'pass' and rule_result_2[-1][key]['result'] == 'fail':
                    new_issues.append(key)
                elif rule_result_1[-1][key]['result'] == 'fail' and rule_result_2[-1][key]['result'] == 'pass':
                    fixed_issues.append(key)
            else :
                unmatched_issues_2.append(key)

        print('[INFO]\nFirst scan summary statistics\nHost: {}\nDate: {}\nTotal: {}\nPassed: {}\nFailed: {}\nNotExecuted: {}\n'.format(file_1[len(self.result_folder):-25], file_1[-24:-5], rule_result_1[0]['stats']['total'], rule_result_1[0]['stats']['pass'], rule_result_1[0]['stats']['fail'], rule_result_1[0]['stats']['total'] - rule_result_1[0]['stats']['pass'] - rule_result_1[0]['stats']['fail']))
        print('[INFO]\nSecond scan summary statistics\nHost: {}\nDate: {}\nTotal: {}\nPassed: {}\nFailed: {}\nNot Executed: {}\n'.format(file_2[len(self.result_folder):-25], file_2[-24:-5], rule_result_2[0]['stats']['total'], rule_result_2[0]['stats']['pass'], rule_result_2[0]['stats']['fail'], rule_result_2[0]['stats']['total'] - rule_result_2[0]['stats']['pass'] - rule_result_2[0]['stats']['fail']))
        
        if fixed_issues:
            print('[INFO] Fixes in second scan')
            for id in fixed_issues:
                print('ID: {}\tSeverity: {}\n'.format(id, rule_result_2[-1][id]['severity']))

        if new_issues:
            print('[INFO] New issues in second scan')
            for id in new_issues:
                print('ID: {}\tSeverity: {}\n'.format(id, rule_result_2[-1][id]['severity']))

        if unmatched_issues_1:
            print('[INFO] Rules missing from second scan')
            for id in unmatched_issues_1:
                print('ID: {}\tSeverity: {}\tResult: {}\n'.format(id, rule_result_1[-1][id]['severity'], rule_result_1[-1][id]['result']))

        if unmatched_issues_2:
            print('[INFO] New rules executed in second scan')
            for id in unmatched_issues_2:
                print('ID: {}\tSeverity: {}\tResult: {}\n'.format(id, rule_result_2[-1][id]['severity'], rule_result_2[-1][id]['result']))

        if not fixed_issues and not new_issues and not unmatched_issues_1 and not unmatched_issues_2:
            print('[INFO] No changes were detected')

    def showScanHistory(self):
        '''
        Displays a list of json files containing past reports generated, along with an ID that can be provided to the tool for comparison or to display a specific report. 
        Files are sorted by date generated.
        '''
        try:
            files = Report.enumerateFilesInDir(self.result_folder)
        except FileNotFoundError as err:
            raise err

        id = 1

        sortedFiles = sorted(files, key=lambda x: os.path.splitext(x.split('_')[-1])[0])

        print("[INFO] Scan history: ")
        for file in sortedFiles:
            print('ID: {} Filename: {}'.format(id, file))
            id+=1
        if id == 1:
            print('[INFO] No scans found')

    def getReportById(self):
        '''
        Displya summary report with ID matching parameter.
        The information displayed is: 
            All rules, with ID, severity and result(pass or fail)
            Summary statistics:
                Target Hostname
                UTC Date of scan
                Number of rules checked
                Number of rules passed
                Number of rules failed
                Number of rules not executed

            Parameters:
                fileID: ID of the file to display
        '''
        try:
            filename = self.getFilenameById(self.scan_id_1)
        except FileNotFoundError as err:
            raise err

        try:
            rule_result = Report.loadJSON(filename)
        except JSONError as err:
            raise err

        for key in rule_result[-1]:
            print('ID: {}\nSeverity: {}\nResult: {}\n'.format(key, rule_result[-1][key]['severity'], rule_result[-1][key]['result']))
        
        print('[INFO:]\nTest Target: {}\nUTC Time: {}\nTotal rules: {}\nPassed: {}\nFailed: {}\nNot Executed: {}'.format(filename[len(self.result_folder):-25], filename[-24:-5], rule_result[0]['stats']['total'], rule_result[0]['stats']['pass'], rule_result[0]['stats']['fail'], rule_result[0]['stats']['total'] - rule_result[0]['stats']['pass'] - rule_result[0]['stats']['fail']))

def parseCommandLine():
        '''
        Parses the command line options
        '''
        parser = argparse.ArgumentParser(description='Command line tool to execute OpenSCAP scans of the Oracle Linux 7 system using the "stig" profile from the "scap-security-guide" package')
        group = parser.add_mutually_exclusive_group()
        group.add_argument('--scan', action='store_true', help='start a new scan')
        group.add_argument('--history', action='store_true', help='list past scans')
        group.add_argument('--scan-id', help='show results of scan with a certain id')
        group.add_argument('--compare', nargs=2, help='compare 2 scans by id')

        if(len(sys.argv) == 1):
            parser.print_help(sys.stderr)
            sys.exit(1)
        return parser.parse_args()


def main():
    args = parseCommandLine()

    if args.scan:
        hostname = socket.gethostname()
        date = strftime("%Y-%m-%dT%H:%M:%S", gmtime())

        try :
            subprocess.check_call([
                    'oscap',
                    'xccdf', 
                    'eval', 
                    '--profile', 
                    'stig', 
                    '--results', 
                    '/root/openscap/results/'+hostname+'_'+date+'.xml',
                    '--cpe',
                    '/usr/share/xml/scap/ssg/content/ssg-ol7-cpe-dictionary.xml',
                    '/usr/share/xml/scap/ssg/content/ssg-ol7-xccdf.xml',
                ])
        except CalledProcessError as cpe:
            if cpe.returncode != 2:
                print('oscap call failed with error code {}'.format(cpe.returncode))
                exit(cpe.returncode)

        reportInstance = Report(xml_to_parse='/root/openscap/results/'+hostname+'_'+date+'.xml')
        try:
            reportInstance.parseReport()
        except XMLError as xmlError:
            print(xmlError)
        except JSONError as jsonError:
            print(jsonError)

    if args.scan_id:
        reportInstance = Report(scan_id_1=args.scan_id)
        try:
            reportInstance.getReportById()
        except FileNotFoundError as fnfError:
            print(fnfError)
        except JSONError as jsonError:
            print(jsonError)

    if args.compare:
        reportInstance = Report(scan_id_1=args.compare[0], scan_id_2=args.compare[1])
        try:
            reportInstance.compareReports()
        except FileNotFoundError as fnfError:
            print(fnfError)
        except JSONError as jsonError:
            print(jsonError)

        
    if args.history:
        reportInstance = Report()
        try:
            reportInstance.showScanHistory()
        except FileNotFoundError as fnfError:
            print(fnfError)

if __name__ == "__main__":
    main()